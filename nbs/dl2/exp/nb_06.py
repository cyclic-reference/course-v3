
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/06_HOOKY.ipynb

from exp.nb_05 import *

def normalizeVectors(xTrainingVector, xValidationVector):
    return vectorNormalization(xTrainingVector), vectorNormalization(xValidationVector
                                                                    )
def vectorNormalization(vector):
    return normalizeVector(vector, vector.mean(), vector.std())

class LambdaLayer(torch.nn.Module):
    def __init__(self, fundie):
        super().__init__()
        self.fundie = fundie

    def forward(self, inputVector):
        return self.fundie(inputVector)

def flattenImage(imageMatrix): return imageMatrix.view(imageMatrix.shape[0], -1)

class GeneralRectifiedLinearUnit(torch.nn.Module):
    def __init__(self, leaky=None, subtractValue=0, maxToClamp=math.inf):
        super().__init__()
        self.leaky, self.subtractValue, self.maxToClamp = leaky, subtractValue, maxToClamp

    def forward(self, inputVector):
        rectifiedVector = \
            Functional.leaky_relu(inputVector, self.leaky) \
                if self.leaky is not None \
                else Functional.relu(inputVector)
        if self.subtractValue > 0: rectifiedVector.sub_(self.subtractValue)
        if self.maxToClamp is not math.inf: rectifiedVector.clamp_max_(self.maxtToClamp)
        return rectifiedVector


layerSizes = [8, 16, 32, 32]

def createBetterConvolutionModel(numberOfClasses):
    return torch.nn.Sequential(*createBetterConvolutionLayers(numberOfClasses, layerSizes)).cuda()

def createBetterConvolutionalLayer(inputSize,
                                   outputSize,
                                   kernelSize=3,
                                   stride=2,
                                   leaky=0.1,
                                   subtractValue=0.4,
                                   maxToClamp=6.0
                                  ):
    return torch.nn.Sequential(torch.nn.Conv2d(inputSize,
                                               outputSize,
                                               kernelSize,
                                               stride,
                                               kernelSize//2),
                               GeneralRectifiedLinearUnit(leaky,
                                                          subtractValue,
                                                          maxToClamp))


def createBetterConvolutionLayers(numberOfClasses, layerSizes):
    adjustedLayerSizes = [1]  + layerSizes # Make the first layer take a dimension of one
    convolutionLayers = [createConvolutionLayer(adjustedLayerSizes[i],
                                               adjustedLayerSizes[i+1],
                                               5 if i == 0 else 3)
                        for i in range(len(adjustedLayerSizes) - 1)]
    finishingLayers = [
        torch.nn.AdaptiveAvgPool2d(1),
        LambdaLayer(flattenImage),
        torch.nn.Linear(layerSizes[-1], numberOfClasses)
    ]
    return [LambdaLayer(resizeImage)] + convolutionLayers + finishingLayers