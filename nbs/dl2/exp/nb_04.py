
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/04_HOLLA_BACK_GURL.ipynb

from exp.nb_03 import *

class DataBunch():
    def __init__(self, trainingDataLoader, validationDataLoader, numberOfClasses):
        self.trainingDataLoader, self.validationDataLoader = trainingDataLoader, validationDataLoader
        self.numberOfClasses = numberOfClasses

    @property
    def trainingDataSet(self): return self.trainingDataLoader

    @property
    def validationDataSet(self): return self.validationDataLoader

def trainModelWithValidation(learnableModel, dataBunch, epochs):
    for epoch in range(epochs):
        for _xTrain, _yTrain in dataBunch.trainingDataLoader:
            _preds = learnableModel(_xTrain)
            loss = Functional.cross_entropy(_preds, _yTrain)
            loss.backward()
            learnableModel.learn()
        accumulatedLoss, accumulatedAccuracy = 0.,0.
        for _xValidation, _yValidation in dataBunch.validationDataLoader:
            with torch.no_grad(): # do not produce gradients when running loss function
                _preds = learnableModel(_xValidation)
                accumulatedLoss += Functional.cross_entropy(_preds, _yValidation)
                accumulatedAccuracy += accuracy(_preds, _yValidation)
        numberOfItems = len(validationDataLoader)
        print("Epoch {}, Accuracy {}, Loss {}".format(epoch, accumulatedAccuracy/numberOfItems, accumulatedLoss/numberOfItems))

class CNNModel(torch.nn.Module):
    def __init__(self, inputSize, numberHiddenLayers, classes):
        super().__init__()
        self.layers = torch.nn.Sequential(
            torch.nn.Linear(inputSize, numberHiddenLayers),
            torch.nn.ReLU(),
            torch.nn.Linear(numberHiddenLayers, classes)
        )

    def __call__(self, inputMatrix): return self.layers(inputMatrix)
