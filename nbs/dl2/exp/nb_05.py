
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/05_ANNEAL_BEFORE_ZOD.ipynb

from exp.nb_04 import *

from functools import partial

def FixedRange(schedulingFunction):
    def _fixedScheduler(start, end): return partial(schedulingFunction, start, end)
    return _fixedScheduler


@FixedRange
def cosineScheduler(start, end, timePosition): return start + (1 + math.cos(math.pi*(1-timePosition))) * (end-start) / 2

@FixedRange
def constantScheduler(start, end, timePosition): return start

@FixedRange
def exponentialScheduler(start, end, timePosition): return start * (end / start)**timePosition


from typing import *

def listify(o):
    if o is None: return []
    if isinstance(o, list): return o
    if isinstance(o, str): return [o]
    if isinstance(o, Iterable): return list(o)
    return [o]

def aggregateSchedulers(appliedPercentages, schedulers):
    assert sum(appliedPercentages) == 1
    percentages = tensor([0] + listify(appliedPercentages))
    assert torch.all(percentages >= 0)
    percentages = torch.cumsum(percentages, 0) # each vector component is the aggregation of it and the one before it
    def _inner(timePosition):
        currentIndex = (timePosition >= percentages).nonzero().max()
        actualPosition = (timePosition-percentages[currentIndex]) / (percentages[currentIndex+1]-percentages[currentIndex])
        return schedulers[currentIndex](actualPosition)
    return _inner

def createCosineSchedulers(start, high, end):
    return [cosineScheduler(start, high), cosineScheduler(high, end)]